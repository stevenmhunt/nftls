<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: certificateChains.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: certificateChains.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const _ = require('lodash');
const platforms = require('./platforms');
const connectors = require('./connectors');
const { inspectCertificate, validateCertificate } = require('./certificates');
const { getCertificateAuthorities } = require('./certificateAuthorities');
const { calculateChainPaths, extractPath } = require('./utils');
const { inMemory } = require('./storage');
const { ROOT_CERT_PATH } = require('./constants');
const { getCachedCertificate } = require('./cachedCertificates');

/**
 * @private
 * Follows a predicted certificate chain path in order to locate and validate certificates.
 * @param {object} context The session context.
 * @param {object} paths The path names to follow.
 * @param {string} name The next path name to find.
 * @param {string} addr The next address to find.
 * @param {string} forAddr The next for address to find.
 * @param {string} target The target address we're trying to reach.
 * @returns {Array} A list of all acquired certificates.
 */
async function resolveCertificateChain(context, paths, name, addr, forAddr, isContract, target) {
    const { pathName, platformName } = extractPath(name);
    if (paths.length === 0 || (addr === target &amp;&amp; paths[0] !== ROOT_CERT_PATH)) {
        // if we ran out of paths to validate, then we successfully walked across the chain.
        return [];
    }

    // a contract has been encounted which means we've crossed a token boundary.
    if (forAddr &amp;&amp; isContract) {
        await context.platforms[platformName].setTokenContract(forAddr);
    }

    // acquire certificate.
    let data = await getCachedCertificate(context, name, addr);
    if (!data) {
        try {
            const cert = await context.platforms[platformName].downloadCertificate(pathName);
            data = await inspectCertificate(cert);
        } catch (err) {
            // console.log(err);
            // if we can't get data from the blockchain, then the chain validation is incomplete.
        }
    }

    // if we don't find a certificate that matches our criteria, then the chain is broken.
    if (!data) {
        return [null];
    }

    // analyze certificate.
    const nextAddress = data.certificate.requestAddress;
    const nextfor = data.certificate.forAddress;
    const nextIsContract = data.certificate.contractNonce !== undefined;
    const { status, error } = await validateCertificate(data, addr);
    data.status = status;

    // if something bad happened, then we can't complete the chain.
    if (error) {
        return [null];
    }

    // if we found the target address, then we completed the chain.
    if (addr === target) {
        return [data];
    }

    return [data,
        ...await resolveCertificateChain(
            context,
            paths.slice(1),
            `${paths[0]}@${platformName}`,
            nextAddress,
            nextfor,
            nextIsContract,
            target,
        ),
    ];
    // TODO: add cycle detection.
}

/**
 * Inspects certificate chain information for a given certificate.
 * Note: requires an Internet connection.
 * @param {object} context The session context.
 * @param {*} certData The certificate to inspect chain data from.
 * @returns {Promise&lt;object>} Any located certificates, as well as whether the chain status.
 */
async function inspectCertificateChain(context, certData) {
    const data = await inspectCertificate(certData);
    if ((await validateCertificate(data)).error) {
        throw new Error('The provided certificate is not valid.');
    }

    const targetAddress = data.signatureAddress;
    const targetName = data.certificate.subject.name;
    const { pathName: certPath, platformName: certPlatform } = extractPath(targetName);
    const paths = [
        certPath,
        ...calculateChainPaths(certPath),
    ].reverse().slice(1);
    const CAs = (await getCertificateAuthorities(context))
        .filter((i) => i.platform === certPlatform
            || platforms[certPlatform].getCompatiblePlatforms().indexOf(i.platform) >= 0);
    // TODO: reseach whether this process could be performed in parallel safely.
    for (let i = 0; i &lt; CAs.length; i += 1) {
        // eslint-disable-next-line no-await-in-loop
        const chain = await resolveCertificateChain(
            context,
            paths,
            `@${certPlatform}`,
            CAs[i].address,
            CAs[i].forAddress,
            true,
            targetAddress,
        );
        if (chain.length === 0 || chain[chain.length - 1]) {
            return { status: 'Complete', chain };
        }
        if (chain.length > 0) {
            return { status: 'Incomplete', chain };
        }
    }
    return { status: 'CA Not Found', chain: [] };
}

/**
 * Verifies whether a certificate and its chain of certificates is valid.
 * @param {object} context The session context.
 * @param {*} certData The certificate to validate chain data from.
 * @returns {Promise&lt;string>} Returns "Verified" if verified, otherwise returns an error message.
 */
async function validateCertificateChain(context, certData) {
    const { status } = await inspectCertificateChain(context, certData);
    if (status === 'Complete') {
        return { status: 'Valid' };
    }
    return { status: 'Invalid', error: status };
}

async function acquireSessionContext(platformOptions, storageOptions = null) {
    const platformConnectors = {};
    await Promise.all(_.keys(platformOptions).map(async (platform) => {
        platformConnectors[platform] = await connectors[platform](platformOptions[platform]);
    }));
    return {
        platforms: platformConnectors,
        storage: storageOptions || await inMemory(),
    };
}

module.exports = {
    inspectCertificateChain,
    validateCertificateChain,
    acquireSessionContext,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addCachedCertificate">addCachedCertificate</a></li><li><a href="global.html#addCertificateAuthority">addCertificateAuthority</a></li><li><a href="global.html#getCachedCertificate">getCachedCertificate</a></li><li><a href="global.html#getCertificateAuthorities">getCertificateAuthorities</a></li><li><a href="global.html#inspectCertificate">inspectCertificate</a></li><li><a href="global.html#inspectCertificateChain">inspectCertificateChain</a></li><li><a href="global.html#installCertificate">installCertificate</a></li><li><a href="global.html#issueCertificate">issueCertificate</a></li><li><a href="global.html#removeCachedCertificate">removeCachedCertificate</a></li><li><a href="global.html#removeCertificateAuthority">removeCertificateAuthority</a></li><li><a href="global.html#renderCertificateToken">renderCertificateToken</a></li><li><a href="global.html#requestCertificate">requestCertificate</a></li><li><a href="global.html#validateCertificate">validateCertificate</a></li><li><a href="global.html#validateCertificateChain">validateCertificateChain</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Wed Jan 26 2022 10:43:04 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
